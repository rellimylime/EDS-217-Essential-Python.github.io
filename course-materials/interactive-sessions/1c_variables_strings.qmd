---
title: "Interactive Session 1C"
subtitle: "üêç Exploring Variable Types and Strings in Python"
jupyter: eds217_2025
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: show
---

::: {style="width: 80%; margin: auto;"}
![](images/variable_2.jpeg)
:::

:::{.gray-text .center-text}
*A cartoon depicting the idea of a variable.* [MidJourney 5](https://www.midjourney.com/jobs/7d8b78b4-61a1-49b2-9187-0bed8b4d8127?index=0)
:::

Understanding the types of variables and the methods available for different objects is crucial for effective programming in Python. This guide will walk you through how to determine the type of a variable and explore the methods you can use with various objects.

## Getting Started

Before we begin our interactive session, please follow these steps to set up your Jupyter Notebook:

1. Open JupyterLab and create a new notebook:
   - Click on the `+` button in the top left corner
   - Select `Python 3.11.0` from the Notebook options

2. Rename your notebook:
   - Right-click on the `Untitled.ipynb` tab (see the note below if you have trouble!)
   - Select "Rename"
   - Name your notebook with the format: `Session_1C_Variables_and_Strings.ipynb`

:::{.callout-tip title="Right-clicking in JupyterLab"}
Some browsers and operating system combinations will not conceded right-clicking to the JupyterLab interface and will show a system menu when you try to right click. In those cases, usually `CTRL-Right Click` or `OPTION-Right Click` will bring up the Jupyter menu.
:::

3. Add a title cell:
   - In the first cell of your notebook, change the cell type to "Markdown"
   - Add the following content (replace the placeholders with the actual information):

```markdown
# Day 1: Session C - Variables & Strings

[Session Webpage](https://eds-217-essential-python.github.io/course-materials/interactive-sessions/1c_variables_strings.html)

Date: 09/02/2025
```

4. Add a code cell:
   - Below the title cell, add a new cell
   - Ensure it's set as a "Code" cell
   - This will be where you start writing your Python code for the session

5. Throughout the session:
   - Take notes in Markdown cells
   - Copy or write code in Code cells
   - Run cells to test your code
   - Ask questions if you need clarification

:::{.callout-caution}
Remember to save your work frequently by clicking the save icon or using the keyboard shortcut (Ctrl+S or Cmd+S).
:::

Let's begin our interactive session!

## Variable Types

In Python, **everything is an object**. Each object has a specific type, and knowing the type of a variable helps you understand what operations and methods you can perform on it.

### Determining Variable Type

To find out the type of a variable, you can use the `type()` function. This function returns the type of the object passed to it.

```{python}
#| include-output: false

# Define some variables
my_number = 42
my_text = "Hello, World!"
my_pi = 3.14159
my_data = [1, 2, 3, 4, 5]

# Determine the type of each variable
print(type(my_number))
print(type(my_text))
print(type(my_pi))
print(type(my_data))
```

### Built-in Types

Here are some common built-in types in Python:

- `int`: Represents integers.
- `float`: Represents floating-point numbers.
- `str`: Represents strings.
- `list`: Represents lists, which are ordered collections of items.

## Exploring Methods

Once you know the type of an object, you can discover the methods available for that object. Methods are functions that belong to an object and can be used to perform operations on the data contained within the object.

### Discovering Methods

You can use the `dir()` function to list all the attributes and methods available for an object. This function returns a list of the object's attributes and methods, including special methods (also known as "dunder" methods) that begin and end with double underscores.

```{python}
#| include-output: false

# List all methods and attributes of a string object
string_methods = dir(my_text)
print(string_methods)
```

### Filtering User-Facing Methods

While `dir()` lists all methods, you often only need user-facing methods. You can filter out special methods by ignoring those with double underscores.

```{python}
#| include-output: false

# Filter out special methods
user_methods = [method for method in dir(my_text) if not method.startswith('__')]
print(user_methods)
```

## Using Methods

Now that you've discovered the methods available for an object, let's see how to use them. Here are some examples with strings and lists.

### String Methods

Strings in Python have various methods for text manipulation. Let's look at a few commonly used methods.

#### Example: `upper()`, `lower()`, and `replace()`, `strip()`

```{python}
#| include-output: false

text = " Hello, World!  "

# Convert to uppercase
print(my_text.upper())

# Convert to lowercase
print(my_text.lower())

# Replace a substring
print(my_text.replace("World", "Python"))

# Remove leading and trailing whitespace, including tabs and newlines
print(my_text.strip())

```


#### Advanced Example: String Normalization

In this section, we'll explore how to normalize strings using built-in Python string methods. String normalization is a common task in data processing and can involve operations like converting text to lowercase, removing extra whitespace, and replacing spaces with other characters. For example, in `R`, the `janitor` package is often used to normalize dataframe columns names. 

##### Basic String Normalization (Step-by-Step Approach)

Let's start with a simple example of string normalization using a step-by-step approach:

```{python}
#| echo: true

# A string with mixed case and extra spaces
original = "  Hello, World!  "

# Method 1: Step-by-step approach (easier to understand and debug)
# Step 1: Remove leading and trailing whitespace
cleaned = original.strip()

# Step 2: Convert to lowercase
normalized = cleaned.lower()

print(f"Original: '{original}'")
print(f"Step 1 (strip): '{cleaned}'")
print(f"Step 2 (lower): '{normalized}'")
```

In this step-by-step approach, we:
1. **First** use `strip()` to remove leading and trailing whitespace
2. **Then** use `lower()` to convert the string to lowercase

This method is easier to understand because you can see exactly what each step does, and it's easier to debug if something goes wrong.

##### Pro Tip: Method Chaining (The Pythonic Way)

Python allows you to chain methods together, which can make your code more concise and readable:

```{python}
#| echo: true

# Method 2: Method chaining (more Pythonic and concise)
original = "  Hello, World!  "

# Chain the methods together - each method returns the modified string
normalized = original.strip().lower()

print(f"Original: '{original}'")
print(f"Chained result: '{normalized}'")
```

**How method chaining works:**
- `original.strip()` returns a new string with whitespace removed
- `.lower()` is then called on that result, converting it to lowercase
- The final result is stored in `normalized`

**When to use each approach:**
- **Step-by-step**: When learning, debugging, or when you need to see intermediate results
- **Method chaining**: When you're comfortable with the methods and want more concise code

#### Advanced String Normalization

Now, let's look at a more comprehensive approach to string normalization:

```{python}
#| echo: true

# Examples of strings to normalize
examples = [
    "Hello World",
    "  Python Programming  ",
    "STRING NORMALIZATION\n",
    "  Trim  Spaces  ",
    "\tTabs and Newlines\n"
]

print("String Normalization Examples:")
print("==============================")

for original in examples:
    # Method 1: Step-by-step approach (clear and easy to follow)
    # Step 1: Remove leading/trailing whitespace and newlines
    cleaned = original.strip()
    
    # Step 2: Convert to lowercase
    lower_case = cleaned.lower()
    
    # Step 3: Replace internal spaces with underscores
    normalized = lower_case.replace(" ", "_")
    
    print(f"Original: '{original}'")
    print(f"Step 1 (strip): '{cleaned}'")
    print(f"Step 2 (lower): '{lower_case}'")
    print(f"Step 3 (replace): '{normalized}'")
    print()
```

**Pro Tip: The same result using method chaining:**
```{python}
#| echo: true

print("Same results using method chaining:")
print("===================================")

for original in examples:
    # Method 2: Method chaining (more concise)
    normalized = original.strip().lower().replace(" ", "_")
    
    print(f"Original: '{original}'")
    print(f"Chained result: '{normalized}'")
    print()
```

Both approaches give you the same result, but the step-by-step method makes it easier to see what's happening at each stage.

#### Exercise: Practice Both Approaches

Now it's your turn to practice! Try both the step-by-step and method chaining approaches to normalize the given strings according to these rules:

1. Remove leading and trailing whitespace
2. Convert to _uppercase_ (instead of lowercase)
3. Replace spaces with _hyphens_

```{python}
#| echo: true

strings_to_normalize = [
    "data science",
    "  MACHINE learning ",
    "Artificial Intelligence\t",
    " Natural\nLanguage Processing "
]

print("Method 1: Step-by-Step Approach")
print("=================================")

for string in strings_to_normalize:
    # Your step-by-step normalization code here
    normalized = string  # Replace this line with your normalization steps!
    
    print(f"Original: '{string}'")
    print(f"Normalized: '{normalized}'")
    print()
```


```{python}
#| echo: false
#| include: false

print("Solution:")
print("=========")

print("Step-by-Step Solution:")
for string in strings_to_normalize:
    normalized = string.strip().upper().replace(" ", "-")
    
    print(f"Original: '{string}'")
    print(f"Normalized: '{normalized}'")
    print()

print("Method 2: Method Chaining Approach")
print("===================================")

for string in strings_to_normalize:
    # Method chaining approach (more Pythonic)
    normalized = string.strip().upper().replace(" ", "-")
    
    print(f"Original: '{string}'")
    print(f"Chained result: '{normalized}'")
    print()

```

**Pro Tip:** Both approaches give you the same result! The step-by-step method is easier to understand when learning, while method chaining is more Pythonic and concise.

Try experimenting with different normalization techniques or adding your own strings to the list!

### List Methods

Lists also have several useful methods for data manipulation. Here are some examples.

#### Example: `append()`, `remove()`, and `sort()`

```{python}
# | include-output: false

my_numbers = [3, 1, 4, 1, 5, 9]

# Append an item
my_numbers.append(2)
print(my_numbers)

# Remove an item
my_numbers.remove(1)  # Removes the first occurrence of 1
print(my_numbers)

# Sort the list
my_numbers.sort()
print(my_numbers)
```

## String Formatting in Python: What You'll Encounter in the Wild

An essential skill in data science is creating clear, readable output. Python offers several ways to format strings, and you'll encounter all of them in real-world code. Let's explore these approaches, focusing on the modern best practice.

### The Different Approaches

Here's a practical example showing all the string formatting methods you might see:

```{python}
#| echo: true

# Example data - like what you'd use in data science
name = "Alice"
age = 25
score = 87.543

print("=== Different String Formatting Approaches ===")
print()

# 1. String concatenation (you'll see this, but avoid it)
print("Method 1 - String Concatenation (avoid this):")
print("Student: " + name + " is " + str(age) + " years old")
print("Problems: messy, requires str() conversion, hard to read")
print()

# 2. % formatting (old style, still in legacy code)
print("Method 2 - % Formatting (legacy code):")
print("Student: %s is %d years old with %.1f%% score" % (name, age, score))
print("You'll see this in older code and some libraries")
print()

# 3. .format() method (better than %, still common)
print("Method 3 - .format() Method (common in existing code):")
print("Student: {} is {} years old with {:.1f}% score".format(name, age, score))
print("Student: {name} is {age} years old with {score:.1f}% score".format(name=name, age=age, score=score))
print("Better than %, but still verbose")
print()

# 4. F-strings (MODERN APPROACH - use this!)
print("Method 4 - F-strings (MODERN - use this!):")
print(f"Student: {name} is {age} years old with {score:.1f}% score")
print(f"Temperature reading: {score:.2f}¬∞C")
print(f"Data points processed: {age * 1000:,}")
print("‚úÖ Most readable, fastest, and Pythonic!")
```

### Why F-strings are the Modern Standard

F-strings (formatted string literals) are the preferred approach in modern Python because they are:

- **More readable**: Variables appear directly in the string
- **Faster**: Better performance than other methods  
- **More concise**: Less typing and fewer parentheses
- **Feature-rich**: Easy number formatting, expressions, and method calls

:::{.callout-tip title="R vs Python: String Formatting"}
If you're coming from R, here are the equivalent approaches:

**R approaches:**
```r
# R methods
sprintf("Student: %s scored %.1f%%", name, score)
paste("Hello", name, "- you scored", score)
paste0("Temperature: ", temp, "¬∞C")
```

**Python f-string equivalents:**
```python
# Modern Python f-strings
f"Student: {name} scored {score:.1f}%"
f"Hello {name} - you scored {score}"
f"Temperature: {temp}¬∞C"
```

F-strings are similar to R's `sprintf()` but more intuitive, and much cleaner than `paste()`!
:::

### F-string Formatting Examples for Data Science

Here are common formatting patterns you'll use in data analysis:

```{python}
#| echo: true

# Common data science formatting patterns
temperature = 23.456789
count = 1234567
percentage = 0.847

print("=== Data Science F-string Patterns ===")
print()

# Number formatting
print(f"Temperature: {temperature:.2f}¬∞C")  # 2 decimal places
print(f"Data points: {count:,}")           # Thousands separator
print(f"Success rate: {percentage:.1%}")   # Percentage formatting
print()

# Dynamic formatting
precision = 3
print(f"Precise temperature: {temperature:.{precision}f}¬∞C")
print()

# Expressions in f-strings
values = [10, 20, 30, 40, 50]
print(f"Dataset has {len(values)} values with mean {sum(values)/len(values):.1f}")
print()

# Multiple variables with formatting
for i, val in enumerate(values[:3], 1):
    print(f"Sample {i:2d}: {val:5.1f} (squared: {val**2:6.1f})")
```

### Practice Exercise

Try updating this older-style code to use modern f-strings:

```{python}
#| echo: true

# Convert these to f-strings
city = "Santa Barbara"
temp_f = 72
temp_c = (temp_f - 32) * 5/9

# Old style (update these!):
print("Weather in " + city + ":")
print("Temperature: %d¬∞F (%.1f¬∞C)" % (temp_f, temp_c))

# Your f-string versions here:
# print(f"???")
```

```{python}
#| echo: false
#| include: false

# Solution:
print(f"Weather in {city}:")
print(f"Temperature: {temp_f}¬∞F ({temp_c:.1f}¬∞C)")
```

## Special Methods

Special methods, also known as "dunder" (double underscore) methods, allow Python to interpret the behavior of  objects for built-in operations. For example, `__init__` is used for initializing objects, and `__str__` defines the string representation.

While important, these are generally more advanced and used in object-oriented programming, so we will not focus on them in this introductory course.

## Conclusion

This guide has introduced you to determining variable types and exploring the methods available for different objects in Python. By understanding how to discover and use methods, you'll be better equipped to manipulate data and build powerful programs.

Feel free to experiment with the code examples interactively in your Jupyter notebook to deepen your understanding.



::: {.center-text .body-text-xl .teal-text}
End interactive session 1C
:::